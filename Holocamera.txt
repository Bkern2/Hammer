@name Holocamera
@inputs Rec Play
@persist Holo:array Ent:array X Y Z Pos:table 

#FUNCTIONS
function vector scaledPos(E:entity,Scale) {
return entity():pos()+vec(0,0,10)+((E:pos()-entity():pos())/Scale)
}

if(first()) {
X=1
signalSetGroup("camera")
runOnSignal("memory",0,1)
}

interval(10-())

if(Ent:count()<1) {
findByClass("prop_physics")
findClipFromEntity(entity())
Ent=findToArray()
}

elseif(!Holo[X,entity]:isValid() & Ent[X,entity]:isValid()) {

holoCreate(X,scaledPos(Ent[X,entity],10))
holoModel(X,Ent[X,entity]:model())
holoAng(X,Ent[X,entity]:angles())
holoScale(X,vec(1,1,1)/10)

Holo[X,entity]=holoEntity(X)

X++
}
elseif(Rec){ 

if(Holo:count()>perf()) {
#if count > oplimit & datasignal sent

#send signal to memory

}

while(Y<Holo:count() && perf()) {
Y= Y + 1
T = decodeVon(Pos[Y,string])
V = T[T:count(),table][2,vector]

if(scaledPos(Ent[X,entity]):distance(V)>0) {
#distance = square root( ((A:x()-B:x())^2)+(A:y()-B:y())^2)+(A:z()-B:z())^2))

holoPos(Y,V)


}

}

}





