@name Holocamera
@inputs Rec Play
@persist Holo:array Ent:array X Y Z Pos:table 

#[

WHAT COUNTS AS AN OPERATION (op):

definition:
"an operation is a calculation from zero or more input values (called operands) to an output value."



]#

#MATHEMATICAL FUNCTIONS (will not run unless requested)
function vector scaledPos(E:entity,Scale) {
return entity():pos()+vec(0,0,10)+((E:pos()-entity():pos())/Scale)
}

#FIRST EXECUTION
if(first()) {
X=1
signalSetGroup("camera")
runOnSignal("memory",0,1)
}

interval(10-())

#CREATE ENT ARRAY
if(Ent:count()<1) {
findByClass("prop_physics")
findClipFromEntity(entity())
Ent=findToArray()
}

#CREATE OBJECT IN HOLO AT INDEX (X)
elseif(!Holo[X,entity]:isValid() & Ent[X,entity]:isValid()) {

holoCreate(X,scaledPos(Ent[X,entity],10))
holoModel(X,Ent[X,entity]:model())
holoAng(X,Ent[X,entity]:angles())
holoScale(X,vec(1,1,1)/10)

Holo[X,entity]=holoEntity(X)

X++
}

#RECORD POSITIONS
elseif(Rec){ 

if(Holo:count()>perf()) {

#if count > oplimit
#then send signal to group "memory"

#issues:
#doing this wont change count > oplimit, will run more than once.
#will send to any chip with group "memory", multiple chips doing same task
#

only sending new signal once


}

while(Y<Holo:count() && perf()) {
Y= Y + 1
T = decodeVon(Pos[Y,string])
V = T[T:count(),table][2,vector]

if(scaledPos(Ent[X,entity]):distance(V)>0) {
#distance = square root( ((A:x()-B:x())^2)+(A:y()-B:y())^2)+(A:z()-B:z())^2))

holoPos(Y,V)


}

}

}





